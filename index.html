<!DOCTYPE html>
<html lang="en">
  <head>
    <title>VOMMA_3D_Viewer</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <link rel="icon" href="./favicon.ico" type="image/x-icon" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      button {
        position: absolute;
        left: 10px;
        padding: 10px;
        font-size: 14px;
        z-index: 1;
        background: rgba(255, 255, 255, 0.7);
        border: 1px solid #ccc;
        border-radius: 5px;
      }
      #qrcodeContainer {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        z-index: 2;
      }
      #qrcode {
        display: block;
        margin: 0 auto;
      }
      #closeQrCode {
        display: block;
        margin: 0 auto 10px;
        padding: 2.5px 5px;
        background: #333;
        color: white;
        border: none;
        cursor: pointer;
        font-size: 12px;
      }
      #uploadInput {
        display: none;
      }
      #speedControlContainer {
        position: absolute;
        left: 10px;
        bottom: 10px;
        z-index: 1;
        background: rgba(255, 255, 255, 0.7);
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
      }
      #viewButtons {
        position: absolute;
        right: 10px;
        top: 10px;
        z-index: 1;
        display: flex;
        flex-direction: column;
      }
      .view-button {
        margin-bottom: 10px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.7);
        border: 1px solid #ccc;
        border-radius: 5px;
        cursor: pointer;
      }
      .view-button img {
        width: 24px;
        height: 24px;
      }
    </style>
  </head>
  <body>
    <script src="./js/qrcode.min.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "./js/three.module.js",
          "three/addons/": "./js/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { EXRLoader } from "three/addons/loaders/EXRLoader.js";
      import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
      import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
      import { ARButton } from "three/addons/webxr/ARButton.js";

      let container, camera, scene, renderer, controls, mixer;
      let model, modelGroup, ground;
      const originalMaterials = new Map();
      let initialCameraPosition, initialTarget;
      let clock = new THREE.Clock();
      let animationSpeed = 1.0;

      // AR variables
      let reticle; // AR placement indicator
      let hitTestSource = null;
      let hitTestSourceRequested = false;
      let placedInAR = false; // Indicates if the model has been placed in the AR scene

      // 模式：仅纹理 或 无纹理
      const renderModes = {
        Texture: "texture",
        NoTexture: "noTexture",
      };
      let currentMode = renderModes.Texture;

      // 背景文件列表
      const backgroundFiles = [
        "background/scene1.jpg",
        "background/scene2.hdr",
        "background/scene3.exr",
        "background/scene4.jpg",
      ];
      let currentBackgroundIndex = -1;

      init();
      animate();

      function init() {
        container = document.createElement("div");
        document.body.appendChild(container);

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 100);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xd3d3d3); // 浅灰色背景
        scene.fog = new THREE.Fog(0xd3d3d3, 20, 100);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);
        
        const hemiLight2 = new THREE.HemisphereLight(0xffffff, 0x444444);
        hemiLight2.position.set(0, -20, 0);
        scene.add(hemiLight2);

        const dirLight = new THREE.DirectionalLight(0xffffff);
        dirLight.position.set(0, 0, 20);
        scene.add(dirLight);
        const Light3 = new THREE.DirectionalLight(0xffffff);
        Light3.position.set(0, 0, -20);
        scene.add(Light3);
        const Light4 = new THREE.DirectionalLight(0xffffff);
        Light4.position.set(20, 0, 0);
        scene.add(Light4);
        const Light5 = new THREE.DirectionalLight(0xffffff);
        Light5.position.set(-20, 0, 0);
        scene.add(Light5);

        // 地面
        const planeMaterial = new THREE.MeshPhongMaterial({
          color: 0x333333, // 黑灰色地面
          depthWrite: false,
        });
        ground = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), planeMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        let testmodelUrl = "http://data.3d.vommatec.com/VOMMA_Lab/test_wang_1.glb";      
        const urlParams = new URLSearchParams(window.location.search);
        const encodedModelUrl  = urlParams.get('model');
        let modelUrl;
        if (encodedModelUrl ) {
          modelUrl = decodeURIComponent(encodedModelUrl);
          console.log("Decoded URL:", modelUrl);
        } else {
          modelUrl = testmodelUrl;
        }

        console.log("Model URL:", modelUrl);

        // 载入 GLTF 模型
        const loader = new GLTFLoader();
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('./js/draco/'); // 设置 Draco 解码器路径
        loader.setDRACOLoader(dracoLoader);
        
        loader.load(
          modelUrl,
          (gltf) => {
            model = gltf.scene;
            resetModelPositionAndScale(model);

            // 创建一个新的组，并将模型添加到组中
            modelGroup = new THREE.Group();
            modelGroup.add(model);
            scene.add(modelGroup);

            // 调整相机位置和目标
            const center = new THREE.Vector3();
            new THREE.Box3().setFromObject(model).getCenter(center);
            camera.position.set(center.x, center.y, center.z + 8);
            camera.lookAt(center);

            // 保存初始相机位置和目标位置
            initialCameraPosition = camera.position.clone();
            initialTarget = center.clone();

            // 更新轨道控制目标
            controls.target.copy(center);
            controls.update();

            // 设置动画混合器
            mixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach((clip) => {
              mixer.clipAction(clip).play();
            });
          },
          undefined,
          (err) => {
            console.error("Error loading model:", err);
          }
        );

        // 环境光
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);

        const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight1.position.set(0, 0, 20);
        scene.add(dirLight1);

        const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight2.position.set(0, 0, -20);
        scene.add(dirLight2);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, 0);
        controls.minDistance = 1;
        controls.maxDistance = 50;
        controls.update();

        window.addEventListener("resize", onWindowResize);

        const button = document.createElement("button");
        button.innerText = "Toggle No Texture";
        button.style.top = "10px";
        document.body.appendChild(button);
        button.addEventListener("click", toggleNoTextureMode);

        const qrButton = document.createElement("button");
        qrButton.innerText = "Generate QR Code";
        qrButton.style.top = "50px";
        document.body.appendChild(qrButton);
        qrButton.addEventListener("click", generateQRCode);

        const uploadButton = document.createElement("button");
        uploadButton.innerText = "Upload Model";
        uploadButton.style.top = "90px";
        document.body.appendChild(uploadButton);
        uploadButton.addEventListener("click", () => {
          document.getElementById("uploadInput").click();
        });

        const resetViewButton = document.createElement("button");
        resetViewButton.innerText = "Reset View";
        resetViewButton.style.top = "130px";
        document.body.appendChild(resetViewButton);
        resetViewButton.addEventListener("click", resetView);

        const backgroundButton = document.createElement("button");
        backgroundButton.innerText = "Toggle Background";
        backgroundButton.style.top = "170px";
        document.body.appendChild(backgroundButton);
        backgroundButton.addEventListener("click", toggleBackground);

        const uploadInput = document.createElement("input");
        uploadInput.type = "file";
        uploadInput.id = "uploadInput";
        uploadInput.accept = ".glb, .gltf";
        document.body.appendChild(uploadInput);
        uploadInput.addEventListener("change", handleFileUpload);

        const qrCodeContainer = document.createElement("div");
        qrCodeContainer.id = "qrcodeContainer";
        document.body.appendChild(qrCodeContainer);

        const closeQrCodeButton = document.createElement("button");
        closeQrCodeButton.id = "closeQrCode";
        closeQrCodeButton.innerText = "Close";
        qrCodeContainer.appendChild(closeQrCodeButton);

        const qrCodeCanvas = document.createElement("canvas");
        qrCodeCanvas.id = "qrcode";
        qrCodeContainer.appendChild(qrCodeCanvas);

        closeQrCodeButton.addEventListener("click", () => {
          qrCodeContainer.style.display = "none";
        });

        const speedControlContainer = document.createElement("div");
        speedControlContainer.id = "speedControlContainer";
        document.body.appendChild(speedControlContainer);

        const speedControlLabel = document.createElement("label");
        speedControlLabel.innerText = "Animation Speed";
        speedControlLabel.htmlFor = "speedControl";
        speedControlContainer.appendChild(speedControlLabel);

        const speedControl = document.createElement("input");
        speedControl.type = "range";
        speedControl.min = "0.1";
        speedControl.max = "3.0";
        speedControl.step = "0.1";
        speedControl.value = "1.0";
        speedControl.id = "speedControl";
        speedControlContainer.appendChild(speedControl);
        speedControl.addEventListener("input", (event) => {
          animationSpeed = parseFloat(event.target.value);
        });

        const viewButtons = document.createElement("div");
        viewButtons.id = "viewButtons";
        document.body.appendChild(viewButtons);

        const frontViewButton = createViewButton("Front", () => setView(0));
        const sideViewButton = createViewButton("Side", () => setView(Math.PI / 2));
        const backViewButton = createViewButton("Back", () => setView(Math.PI));

        viewButtons.appendChild(frontViewButton);
        viewButtons.appendChild(sideViewButton);
        viewButtons.appendChild(backViewButton);

        // 将ARButton相关代码替换为自定义AR按钮
        const arButtonWrapper = document.createElement('div');
        arButtonWrapper.style.position = 'fixed';
        arButtonWrapper.style.bottom = '75px';
        arButtonWrapper.style.left = '50%';
        arButtonWrapper.style.transform = 'translateX(-50%)';
        arButtonWrapper.style.zIndex = '999';
        document.body.appendChild(arButtonWrapper);

        const customARButton = document.createElement('button');
        customARButton.id = 'customARButton';
        customARButton.textContent = '进入AR查看';
        customARButton.style.background = '#4285f4';
        customARButton.style.color = 'white';
        customARButton.style.border = 'none';
        customARButton.style.borderRadius = '4px';
        customARButton.style.padding = '12px 24px';
        customARButton.style.cursor = 'pointer';
        customARButton.style.fontWeight = 'bold';
        customARButton.style.fontSize = '16px';

        customARButton.addEventListener('click', function() {
          // 获取当前模型URL
          const currentModelUrl = modelUrl || testmodelUrl;
          // 跳转到model-viewer-ar.html并传递模型URL参数
          window.location.href = `model-viewer-ar.html?model=${encodeURIComponent(currentModelUrl)}`;
        });

        arButtonWrapper.appendChild(customARButton);

        // 移除原有的AR相关元素
        const existingARButton = document.getElementById('ARButton');
        if (existingARButton) {
          existingARButton.parentNode.removeChild(existingARButton);
        }
        const arInstructions = document.getElementById('ar-instructions');
        if (arInstructions) {
          arInstructions.parentNode.removeChild(arInstructions);
        }
      }

      function createViewButton(text, onClick) {
        const button = document.createElement("div");
        button.className = "view-button";
        button.innerText = text;
        button.addEventListener("click", onClick);
        return button;
      }

      function setView(angle) {
        if (!initialTarget) {
          console.error("initialTarget is not defined");
          return;
        }
        const quaternion = new THREE.Quaternion();
        quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
        const offset = new THREE.Vector3(0, 0, 8).applyQuaternion(quaternion);
        camera.position.copy(initialTarget).add(offset);
        controls.target.copy(initialTarget);
        controls.update();
      }

      function toggleNoTextureMode() {
        currentMode =
          currentMode === renderModes.Texture
            ? renderModes.NoTexture
            : renderModes.Texture;

        if (model) {
          model.traverse((child) => {
            if (child.isMesh) {
              if (currentMode === renderModes.NoTexture) {
                child.material = new THREE.MeshStandardMaterial({
                  color: 0xb87333,
                  metalness: 0.9,
                  roughness: 0.6,
                  emissive: 0x000000,
                  emissiveIntensity: 0.0,
                });
              } else {
                const originalMaterial = originalMaterials.get(child);
                if (originalMaterial && originalMaterial.map) {
                  child.material = new THREE.MeshBasicMaterial({ map: originalMaterial.map });
                } else {
                  child.material = originalMaterial;
                }
              }
            }
          });
        }
      }

      function toggleBackground() {
        currentBackgroundIndex++;
        if (currentBackgroundIndex >= backgroundFiles.length) {
          scene.background = new THREE.Color(0xd3d3d3);
          scene.add(ground);
          currentBackgroundIndex = -1;
        } else {
          const file = backgroundFiles[currentBackgroundIndex];
          const extension = file.split('.').pop().toLowerCase();

          if (extension === 'exr') {
            const exrLoader = new EXRLoader();
            exrLoader.load(
              file,
              (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.remove(ground);
              },
              undefined,
              (error) => {
                console.error("Error loading EXR:", error);
              }
            );
          } else if (extension === 'hdr') {
            const rgbeLoader = new RGBELoader();
            rgbeLoader.load(
              file,
              (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.remove(ground);
              },
              undefined,
              (error) => {
                console.error("Error loading HDR:", error);
              }
            );
          } else if (extension === 'jpg' || extension === 'jpeg' || extension === 'png') {
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
              file,
              (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.remove(ground);
              },
              undefined,
              (error) => {
                console.error("Error loading image:", error);
              }
            );
          } else {
            console.error("Unsupported background file format:", extension);
          }
        }
      }

      function resetView() {
        if (!initialCameraPosition || !initialTarget) {
          console.error("initialCameraPosition or initialTarget is not defined");
          return;
        }
        camera.position.copy(initialCameraPosition);
        controls.target.copy(initialTarget);
        controls.update();
      }

      function generateQRCode() {
        const qrCodeContainer = document.getElementById("qrcodeContainer");
        const qrCodeCanvas = document.getElementById("qrcode");
        const currentUrl = window.location.href;
        QRCode.toCanvas(qrCodeCanvas, currentUrl, function (error) {
          if (error) console.error(error);
          qrCodeContainer.style.display = "block";
        });
      }

      function handleFileUpload(event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function (e) {
            const contents = e.target.result;
            loadModel(contents);
          };
          reader.readAsArrayBuffer(file);
        }
      }

      function loadModel(contents) {
        const loader = new GLTFLoader();
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('./js/draco/');
        loader.setDRACOLoader(dracoLoader);

        loader.parse(
          contents,
          "",
          (gltf) => {
            if (modelGroup) {
              scene.remove(modelGroup);
            }
            model = gltf.scene;
            resetModelPositionAndScale(model);

            modelGroup = new THREE.Group();
            modelGroup.add(model);
            scene.add(modelGroup);

            const box = new THREE.Box3().setFromObject(model);
            const center = new THREE.Vector3();
            box.getCenter(center);

            camera.position.set(center.x, center.y, center.z + 8);
            camera.lookAt(center);

            initialCameraPosition = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
            initialTarget = center.clone();
            controls.target.copy(center);
            controls.update();

            mixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach((clip) => {
              mixer.clipAction(clip).play();
            });
          },
          (error) => {
            console.error("Error parsing model:", error);
          }
        );
      }

      function resetModelPositionAndScale(model) {
        model.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = false;
            child.receiveShadow = false;
            originalMaterials.set(child, child.material);
            const texture = child.material.map;
            child.material = new THREE.MeshBasicMaterial({ map: texture });
          }
        });
        const box = new THREE.Box3().setFromObject(model);
        const center = new THREE.Vector3();
        box.getCenter(center);
        model.position.sub(center);

        const size = new THREE.Vector3();
        box.getSize(size);
        const maxDimension = Math.max(size.x, size.y, size.z);
        const scaleVal = 5 / maxDimension;
        model.scale.set(scaleVal, scaleVal, scaleVal);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        renderer.setAnimationLoop(render);
      }

      function render() {
        const delta = clock.getDelta() * animationSpeed;
        if (mixer) mixer.update(delta);
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
