<!DOCTYPE html>
<html lang="en">
  <head>
    <title>VOMMA_3D_Viewer</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <link rel="icon" href="./favicon.ico" type="image/x-icon" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      button {
        position: absolute;
        left: 10px;
        padding: 10px;
        font-size: 14px;
        z-index: 1;
        background: rgba(255, 255, 255, 0.7);
        border: 1px solid #ccc;
        border-radius: 5px;
      }
      #qrcodeContainer {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        z-index: 2;
      }
      #qrcode {
        display: block;
        margin: 0 auto;
      }
      #closeQrCode {
        display: block;
        margin: 0 auto 10px;
        padding: 2.5px 5px;
        background: #333;
        color: white;
        border: none;
        cursor: pointer;
        font-size: 12px;
      }
      #uploadInput {
        display: none;
      }
      #speedControlContainer {
        position: absolute;
        left: 10px;
        bottom: 10px;
        z-index: 1;
        background: rgba(255, 255, 255, 0.7);
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
      }
      #viewButtons {
        position: absolute;
        right: 10px;
        top: 10px;
        z-index: 1;
        display: flex;
        flex-direction: column;
      }
      .view-button {
        margin-bottom: 10px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.7);
        border: 1px solid #ccc;
        border-radius: 5px;
        cursor: pointer;
      }
      .view-button img {
        width: 24px;
        height: 24px;
      }
    </style>
  </head>
  <body>
    <script src="./js/qrcode.min.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "./js/three.module.js",
          "three/addons/": "./js/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { EXRLoader } from "three/addons/loaders/EXRLoader.js";
      import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
      import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
      import { ARButton } from "three/addons/webxr/ARButton.js";

      let container, camera, scene, renderer, controls, mixer;
      let model, modelGroup, ground;
      const originalMaterials = new Map();
      let initialCameraPosition, initialTarget;
      let clock = new THREE.Clock();
      let animationSpeed = 1.0;

      // AR variables
      let reticle; // AR placement indicator
      let hitTestSource = null;
      let hitTestSourceRequested = false;
      let placedInAR = false; // Indicates if the model has been placed in the AR scene

      // 模式：仅纹理 或 无纹理
      const renderModes = {
        Texture: "texture",
        NoTexture: "noTexture",
      };
      let currentMode = renderModes.Texture;

      // 背景文件列表
      const backgroundFiles = [
        "background/scene1.jpg",
        "background/scene2.hdr",
        "background/scene3.exr",
        "background/scene4.jpg",
      ];
      let currentBackgroundIndex = -1;

      init();
      animate();

      function init() {
        container = document.createElement("div");
        document.body.appendChild(container);

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 100);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xd3d3d3); // 浅灰色背景
        scene.fog = new THREE.Fog(0xd3d3d3, 20, 100);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);
        
        const hemiLight2 = new THREE.HemisphereLight(0xffffff, 0x444444);
        hemiLight2.position.set(0, -20, 0);
        scene.add(hemiLight2);

        const dirLight = new THREE.DirectionalLight(0xffffff);
        dirLight.position.set(0, 0, 20);
        scene.add(dirLight);
        const Light3 = new THREE.DirectionalLight(0xffffff);
        Light3.position.set(0, 0, -20);
        scene.add(Light3);
        const Light4 = new THREE.DirectionalLight(0xffffff);
        Light4.position.set(20, 0, 0);
        scene.add(Light4);
        const Light5 = new THREE.DirectionalLight(0xffffff);
        Light5.position.set(-20, 0, 0);
        scene.add(Light5);

        // 地面
        const planeMaterial = new THREE.MeshPhongMaterial({
          color: 0x333333, // 黑灰色地面
          depthWrite: false,
        });
        ground = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), planeMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        let testmodelUrl = "http://data.3d.vommatec.com/VOMMA_Lab/test_wang_1.glb";      
        const urlParams = new URLSearchParams(window.location.search);
        const encodedModelUrl  = urlParams.get('model');
        let modelUrl;
        if (encodedModelUrl ) {
          modelUrl = decodeURIComponent(encodedModelUrl);
          console.log("Decoded URL:", modelUrl);
        } else {
          modelUrl = testmodelUrl;
        }

        console.log("Model URL:", modelUrl);

        // 载入 GLTF 模型
        const loader = new GLTFLoader();
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('./js/draco/'); // 设置 Draco 解码器路径
        loader.setDRACOLoader(dracoLoader);
        
        loader.load(
          modelUrl,
          (gltf) => {
            model = gltf.scene;
            resetModelPositionAndScale(model);

            // 创建一个新的组，并将模型添加到组中
            modelGroup = new THREE.Group();
            modelGroup.add(model);
            scene.add(modelGroup);

            // 调整相机位置和目标
            const center = new THREE.Vector3();
            new THREE.Box3().setFromObject(model).getCenter(center);
            camera.position.set(center.x, center.y, center.z + 8);
            camera.lookAt(center);

            // 保存初始相机位置和目标位置
            initialCameraPosition = camera.position.clone();
            initialTarget = center.clone();

            // 更新轨道控制目标
            controls.target.copy(center);
            controls.update();

            // 设置动画混合器
            mixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach((clip) => {
              mixer.clipAction(clip).play();
            });
          },
          undefined,
          (err) => {
            console.error("Error loading model:", err);
          }
        );

        // 环境光
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);

        const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight1.position.set(0, 0, 20);
        scene.add(dirLight1);

        const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight2.position.set(0, 0, -20);
        scene.add(dirLight2);

        // 创建AR放置指示器
        const reticleGeometry = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
        const reticleMaterial = new THREE.MeshBasicMaterial();
        reticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);

        // 渲染器
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // 添加alpha通道以支持透明背景
        renderer.xr.enabled = true;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);

        // 添加AR会话开始和结束的监听器
        renderer.xr.addEventListener('sessionstart', function () {
          console.log('AR session started');
          scene.background = null;
          scene.fog = null;
          scene.remove(ground);
          
          document.querySelectorAll('button').forEach(btn => {
            if (btn.id !== 'ARButton') btn.style.display = 'none';
          });
          document.getElementById('speedControlContainer').style.display = 'none';
          document.getElementById('viewButtons').style.display = 'none';
          
          placedInAR = false;
          
          if (modelGroup) {
            modelGroup.visible = false;
          }
        });

        renderer.xr.addEventListener('sessionend', function () {
          console.log('AR session ended');
          scene.background = new THREE.Color(0xd3d3d3);
          scene.fog = new THREE.Fog(0xd3d3d3, 20, 100);
          scene.add(ground);
          
          document.querySelectorAll('button').forEach(btn => {
            btn.style.display = '';
          });
          document.getElementById('speedControlContainer').style.display = '';
          document.getElementById('viewButtons').style.display = '';
          
          if (modelGroup) {
            modelGroup.visible = true;
            resetModelPositionAndScale(model);
          }
          
          hitTestSource = null;
          hitTestSourceRequested = false;
          reticle.visible = false;
        });

        const arButtonWrapper = document.createElement('div');
        arButtonWrapper.style.position = 'fixed';
        arButtonWrapper.style.bottom = '75px';
        arButtonWrapper.style.left = '50%';
        arButtonWrapper.style.transform = 'translateX(-50%)';
        arButtonWrapper.style.zIndex = '999';
        document.body.appendChild(arButtonWrapper);
        
        const arButton = ARButton.createButton(renderer, {
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.body }
        });
        arButtonWrapper.appendChild(arButton);
        
        const arInstructions = document.createElement('div');
        arInstructions.id = 'ar-instructions';
        arInstructions.style.position = 'fixed';
        arInstructions.style.top = '50%';
        arInstructions.style.left = '50%';
        arInstructions.style.transform = 'translate(-50%, -50%)';
        arInstructions.style.background = 'rgba(0,0,0,0.7)';
        arInstructions.style.color = 'white';
        arInstructions.style.padding = '20px';
        arInstructions.style.borderRadius = '10px';
        arInstructions.style.textAlign = 'center';
        arInstructions.style.display = 'none';
        arInstructions.style.zIndex = '1000';
        arInstructions.innerHTML = '找到一个平面，<br>然后点击圆环放置模型';
        document.body.appendChild(arInstructions);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, 0);
        controls.minDistance = 1;
        controls.maxDistance = 50;
        controls.update();

        window.addEventListener("resize", onWindowResize);

        const button = document.createElement("button");
        button.innerText = "Toggle No Texture";
        button.style.top = "10px";
        document.body.appendChild(button);
        button.addEventListener("click", toggleNoTextureMode);

        const qrButton = document.createElement("button");
        qrButton.innerText = "Generate QR Code";
        qrButton.style.top = "50px";
        document.body.appendChild(qrButton);
        qrButton.addEventListener("click", generateQRCode);

        const uploadButton = document.createElement("button");
        uploadButton.innerText = "Upload Model";
        uploadButton.style.top = "90px";
        document.body.appendChild(uploadButton);
        uploadButton.addEventListener("click", () => {
          document.getElementById("uploadInput").click();
        });

        const resetViewButton = document.createElement("button");
        resetViewButton.innerText = "Reset View";
        resetViewButton.style.top = "130px";
        document.body.appendChild(resetViewButton);
        resetViewButton.addEventListener("click", resetView);

        const backgroundButton = document.createElement("button");
        backgroundButton.innerText = "Toggle Background";
        backgroundButton.style.top = "170px";
        document.body.appendChild(backgroundButton);
        backgroundButton.addEventListener("click", toggleBackground);

        const uploadInput = document.createElement("input");
        uploadInput.type = "file";
        uploadInput.id = "uploadInput";
        uploadInput.accept = ".glb, .gltf";
        document.body.appendChild(uploadInput);
        uploadInput.addEventListener("change", handleFileUpload);

        const qrCodeContainer = document.createElement("div");
        qrCodeContainer.id = "qrcodeContainer";
        document.body.appendChild(qrCodeContainer);

        const closeQrCodeButton = document.createElement("button");
        closeQrCodeButton.id = "closeQrCode";
        closeQrCodeButton.innerText = "Close";
        qrCodeContainer.appendChild(closeQrCodeButton);

        const qrCodeCanvas = document.createElement("canvas");
        qrCodeCanvas.id = "qrcode";
        qrCodeContainer.appendChild(qrCodeCanvas);

        closeQrCodeButton.addEventListener("click", () => {
          qrCodeContainer.style.display = "none";
        });

        const speedControlContainer = document.createElement("div");
        speedControlContainer.id = "speedControlContainer";
        document.body.appendChild(speedControlContainer);

        const speedControlLabel = document.createElement("label");
        speedControlLabel.innerText = "Animation Speed";
        speedControlLabel.htmlFor = "speedControl";
        speedControlContainer.appendChild(speedControlLabel);

        const speedControl = document.createElement("input");
        speedControl.type = "range";
        speedControl.min = "0.1";
        speedControl.max = "3.0";
        speedControl.step = "0.1";
        speedControl.value = "1.0";
        speedControl.id = "speedControl";
        speedControlContainer.appendChild(speedControl);
        speedControl.addEventListener("input", (event) => {
          animationSpeed = parseFloat(event.target.value);
        });

        const viewButtons = document.createElement("div");
        viewButtons.id = "viewButtons";
        document.body.appendChild(viewButtons);

        const frontViewButton = createViewButton("Front", () => setView(0));
        const sideViewButton = createViewButton("Side", () => setView(Math.PI / 2));
        const backViewButton = createViewButton("Back", () => setView(Math.PI));

        viewButtons.appendChild(frontViewButton);
        viewButtons.appendChild(sideViewButton);
        viewButtons.appendChild(backViewButton);
      }

      function createViewButton(text, onClick) {
        const button = document.createElement("div");
        button.className = "view-button";
        button.innerText = text;
        button.addEventListener("click", onClick);
        return button;
      }

      function setView(angle) {
        if (!initialTarget) {
          console.error("initialTarget is not defined");
          return;
        }
        const quaternion = new THREE.Quaternion();
        quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
        const offset = new THREE.Vector3(0, 0, 8).applyQuaternion(quaternion);
        camera.position.copy(initialTarget).add(offset);
        controls.target.copy(initialTarget);
        controls.update();
      }

      function toggleNoTextureMode() {
        currentMode =
          currentMode === renderModes.Texture
            ? renderModes.NoTexture
            : renderModes.Texture;

        if (model) {
          model.traverse((child) => {
            if (child.isMesh) {
              if (currentMode === renderModes.NoTexture) {
                child.material = new THREE.MeshStandardMaterial({
                  color: 0xb87333,
                  metalness: 0.9,
                  roughness: 0.6,
                  emissive: 0x000000,
                  emissiveIntensity: 0.0,
                });
              } else {
                const originalMaterial = originalMaterials.get(child);
                if (originalMaterial && originalMaterial.map) {
                  child.material = new THREE.MeshBasicMaterial({ map: originalMaterial.map });
                } else {
                  child.material = originalMaterial;
                }
              }
            }
          });
        }
      }

      function toggleBackground() {
        currentBackgroundIndex++;
        if (currentBackgroundIndex >= backgroundFiles.length) {
          scene.background = new THREE.Color(0xd3d3d3);
          scene.add(ground);
          currentBackgroundIndex = -1;
        } else {
          const file = backgroundFiles[currentBackgroundIndex];
          const extension = file.split('.').pop().toLowerCase();

          if (extension === 'exr') {
            const exrLoader = new EXRLoader();
            exrLoader.load(
              file,
              (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.remove(ground);
              },
              undefined,
              (error) => {
                console.error("Error loading EXR:", error);
              }
            );
          } else if (extension === 'hdr') {
            const rgbeLoader = new RGBELoader();
            rgbeLoader.load(
              file,
              (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.remove(ground);
              },
              undefined,
              (error) => {
                console.error("Error loading HDR:", error);
              }
            );
          } else if (extension === 'jpg' || extension === 'jpeg' || extension === 'png') {
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
              file,
              (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = texture;
                scene.remove(ground);
              },
              undefined,
              (error) => {
                console.error("Error loading image:", error);
              }
            );
          } else {
            console.error("Unsupported background file format:", extension);
          }
        }
      }

      function resetView() {
        if (!initialCameraPosition || !initialTarget) {
          console.error("initialCameraPosition or initialTarget is not defined");
          return;
        }
        camera.position.copy(initialCameraPosition);
        controls.target.copy(initialTarget);
        controls.update();
      }

      function generateQRCode() {
        const qrCodeContainer = document.getElementById("qrcodeContainer");
        const qrCodeCanvas = document.getElementById("qrcode");
        const currentUrl = window.location.href;
        QRCode.toCanvas(qrCodeCanvas, currentUrl, function (error) {
          if (error) console.error(error);
          qrCodeContainer.style.display = "block";
        });
      }

      function handleFileUpload(event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function (e) {
            const contents = e.target.result;
            loadModel(contents);
          };
          reader.readAsArrayBuffer(file);
        }
      }

      function loadModel(contents) {
        const loader = new GLTFLoader();
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('./js/draco/');
        loader.setDRACOLoader(dracoLoader);

        loader.parse(
          contents,
          "",
          (gltf) => {
            if (modelGroup) {
              scene.remove(modelGroup);
            }
            model = gltf.scene;
            resetModelPositionAndScale(model);

            modelGroup = new THREE.Group();
            modelGroup.add(model);
            scene.add(modelGroup);

            const box = new THREE.Box3().setFromObject(model);
            const center = new THREE.Vector3();
            box.getCenter(center);

            camera.position.set(center.x, center.y, center.z + 8);
            camera.lookAt(center);

            initialCameraPosition = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
            initialTarget = center.clone();
            controls.target.copy(center);
            controls.update();

            mixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach((clip) => {
              mixer.clipAction(clip).play();
            });
          },
          (error) => {
            console.error("Error parsing model:", error);
          }
        );
      }

      function resetModelPositionAndScale(model) {
        model.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = false;
            child.receiveShadow = false;
            originalMaterials.set(child, child.material);
            const texture = child.material.map;
            child.material = new THREE.MeshBasicMaterial({ map: texture });
          }
        });
        const box = new THREE.Box3().setFromObject(model);
        const center = new THREE.Vector3();
        box.getCenter(center);
        model.position.sub(center);

        const size = new THREE.Vector3();
        box.getSize(size);
        const maxDimension = Math.max(size.x, size.y, size.z);
        const scaleVal = 5 / maxDimension;
        model.scale.set(scaleVal, scaleVal, scaleVal);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        renderer.setAnimationLoop(render);
      }

      function render() {
        const delta = clock.getDelta() * animationSpeed;
        if (mixer) mixer.update(delta);
        
        if (renderer.xr.isPresenting) {
          document.getElementById('ar-instructions').style.display = placedInAR ? 'none' : 'block';
          
          const session = renderer.xr.getSession();
          
          if (session && hitTestSourceRequested === false) {
            session.requestReferenceSpace('viewer').then(function (referenceSpace) {
              session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
                hitTestSource = source;
              });
            });
            
            session.addEventListener('end', function () {
              hitTestSourceRequested = false;
              hitTestSource = null;
            });
            
            hitTestSourceRequested = true;
          }
          
          if (hitTestSource) {
            const referenceSpace = renderer.xr.getReferenceSpace();
            hitTestSource.getHitTestResults(referenceSpace).then(function (results) {
              if (results.length) {
                const hit = results[0];
                reticle.visible = !placedInAR;
                reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                
                if (!placedInAR && session.inputSources[0].gamepad && session.inputSources[0].gamepad.buttons[0].pressed) {
                  placeModelInAR(hit.getPose(referenceSpace).transform.matrix);
                }
              } else {
                reticle.visible = false;
              }
            });
          }
        }
        
        renderer.render(scene, camera);
      }
      
      function placeModelInAR(matrix) {
        if (!modelGroup || placedInAR) return;
        
        const transform = new THREE.Matrix4().fromArray(matrix);
        modelGroup.position.setFromMatrixPosition(transform);
        modelGroup.quaternion.setFromRotationMatrix(transform);
        
        const currentScale = modelGroup.scale.x;
        modelGroup.scale.multiplyScalar(0.5 / currentScale);
        
        modelGroup.visible = true;
        placedInAR = true;
        
        document.getElementById('ar-instructions').style.display = 'none';
        
        window.addEventListener('dblclick', resetARPlacement, { once: true });
        
        console.log('Model placed in AR');
      }
      
      function resetARPlacement() {
        if (renderer.xr.isPresenting && placedInAR) {
          placedInAR = false;
          if (modelGroup) {
            modelGroup.visible = false;
          }
          reticle.visible = true;
          document.getElementById('ar-instructions').style.display = 'block';
          console.log('AR placement reset');
        }
      }
    </script>
  </body>
</html>
